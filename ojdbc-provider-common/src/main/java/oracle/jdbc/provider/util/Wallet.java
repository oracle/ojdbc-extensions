/*
 ** Copyright (c) 2023 Oracle and/or its affiliates.
 **
 ** The Universal Permissive License (UPL), Version 1.0
 **
 ** Subject to the condition set forth below, permission is hereby granted to any
 ** person obtaining a copy of this software, associated documentation and/or data
 ** (collectively the "Software"), free of charge and under any and all copyright
 ** rights in the Software, and any and all patent rights owned or freely
 ** licensable by each licensor hereunder covering either (i) the unmodified
 ** Software as contributed to or provided by such licensor, or (ii) the Larger
 ** Works (as defined below), to deal in both
 **
 ** (a) the Software, and
 ** (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 ** one is included with the Software (each a "Larger Work" to which the Software
 ** is contributed by such licensors),
 **
 ** without restriction, including without limitation the rights to copy, create
 ** derivative works of, display, perform, and distribute the Software and make,
 ** use, sell, offer for sale, import, export, have made, and have sold the
 ** Software and the Larger Work(s), and to sublicense the foregoing rights on
 ** either these or other terms.
 **
 ** This license is subject to the following condition:
 ** The above copyright notice and either this complete permission notice or at
 ** a minimum a reference to the UPL must be included in all copies or
 ** substantial portions of the Software.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 ** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 ** SOFTWARE.
 */

package oracle.jdbc.provider.util;

import javax.net.ssl.SSLContext;
import java.io.IOException;
import java.security.KeyStore;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

/**
 * <p>
 * Represents a wallet zip generated by the ADB service. The contents of the zip
 * archive which are relevant to Oracle JDBC are the tnsnames.ora file, the
 * ojdbc.properties file, and the keystore.jks and truststore.jks files. This
 * exposes the content of these files as higher level abstractions. The
 * connection strings of tnsnames.ora are exposed as {@code String} objects for
 * each consumer group. The JKS keystore and trust store are exposed as an
 * {@link SSLContext} object.
 * </p><p>
 * Along with JKS files, the wallet as a zip also contains SSO and PKCS12 files
 * that contain the same key and trust material. To process these files, Oracle
 * JDBC requires a dependency on the Oracle PKI security provider. The JKS file
 * is chosen over the SSO or PKCS12 files in order to avoid this dependency.
 * </p>
 */
public final class Wallet {

  /** Name of the tnsnames.ora file in a wallet zip */
  private static final String TNS_NAMES_FILE = "tnsnames.ora";

  /** Name of the keystore file in a wallet zip */
  private static final String KEY_STORE_FILE = "keystore.jks";

  /** Name of the truststore file in a wallet zip */
  private static final String TRUST_STORE_FILE = "truststore.jks";

  /** Type of the keystore file in a wallet zip */
  private static final String KEY_STORE_TYPE = "JKS";

  /** Contents of the tnsnames.ora file */
  private final TNSNames tnsNames;

  /**
   * An {@code SSLContext} initialized with key and trust material of the
   * keystore.jks and truststore.jks files.
   */
  private final SSLContext sslContext;

  private Wallet(TNSNames tnsNames, SSLContext sslContext) {
    this.tnsNames = tnsNames;
    this.sslContext = sslContext;
  }

  /**
   * @return an {@code SSLContext} initialized with key and trust material from
   * a wallet. Not null.
   */
  public SSLContext getSSLContext() {
    return sslContext;
  }

  /**
   * @return The connection string for high consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * high consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getHighConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.HIGH);
  }

  /**
   * @return The connection string for medium consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * medium consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getMediumConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.MEDIUM);
  }

  /**
   * @return The connection string for low consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * low consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getLowConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.LOW);
  }

  /**
   * @return The connection string for transaction processing (tp) consumer
   * group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * transaction processing (tp) consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getTransactionProcessingConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.TRANSACTION_PROCESSING);
  }

  /**
   * @return The connection string for transaction processing urgent (tpurgent)
   * consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * transaction processing urgent (tpurgent) consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getTransactionProcessingUrgentConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.TRANSACTION_PROCESSING_URGENT);
  }

  private String getConnectionString(TNSNames.ConsumerGroup consumerGroup) {
    String connectionString = tnsNames.getConnectionString(consumerGroup);

    if (connectionString == null) {
      throw new IllegalStateException(
        "No connection string available for consumer group: " + consumerGroup);
    }

    return connectionString;
  }

  /**
   * Unzips the stream of a wallet directory, returning a {@code Wallet} that
   * retains the contents of any files relevant to Oracle JDBC.
   * @throws IllegalStateException If the files are not found or can not be
   * decoded.
   */
  public static Wallet unzip(ZipInputStream zipStream, char[] password) {

    TNSNames tnsNames = null;
    KeyStore keyStore = null;
    KeyStore trustStore = null;

    try {
      for (ZipEntry entry = zipStream.getNextEntry(); entry != null; entry = zipStream.getNextEntry()) {
        switch (entry.getName()) {
          case TNS_NAMES_FILE:
            tnsNames = TNSNames.read(zipStream);
            break;
          case KEY_STORE_FILE:
            keyStore =
              TlsUtils.loadKeyStore(zipStream, password, KEY_STORE_TYPE, null);
            break;
          case TRUST_STORE_FILE:
            trustStore =
              TlsUtils.loadKeyStore(zipStream, null, KEY_STORE_TYPE, null);
            break;
          default:
            // Ignore other files
        }
      }
    }
    catch (IOException ioException) {
      throw new IllegalStateException("Failed to read wallet ZIP", ioException);
    }

    if (tnsNames == null)
      throw missingFile(TNS_NAMES_FILE);

    if (keyStore == null)
      throw missingFile(KEY_STORE_FILE);

    if (trustStore == null)
      throw missingFile(TRUST_STORE_FILE);

    return new Wallet(
      tnsNames,
      TlsUtils.createSSLContext(keyStore, trustStore, password));
  }

  /** Returns an exception for a missing file in the wallet ZIP */
  private static IllegalStateException missingFile(String fileName) {
    return new IllegalStateException("Wallet ZIP did not contain: " + fileName);
  }

}
