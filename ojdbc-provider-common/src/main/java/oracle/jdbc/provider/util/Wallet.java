/*
 ** Copyright (c) 2023 Oracle and/or its affiliates.
 **
 ** The Universal Permissive License (UPL), Version 1.0
 **
 ** Subject to the condition set forth below, permission is hereby granted to any
 ** person obtaining a copy of this software, associated documentation and/or data
 ** (collectively the "Software"), free of charge and under any and all copyright
 ** rights in the Software, and any and all patent rights owned or freely
 ** licensable by each licensor hereunder covering either (i) the unmodified
 ** Software as contributed to or provided by such licensor, or (ii) the Larger
 ** Works (as defined below), to deal in both
 **
 ** (a) the Software, and
 ** (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 ** one is included with the Software (each a "Larger Work" to which the Software
 ** is contributed by such licensors),
 **
 ** without restriction, including without limitation the rights to copy, create
 ** derivative works of, display, perform, and distribute the Software and make,
 ** use, sell, offer for sale, import, export, have made, and have sold the
 ** Software and the Larger Work(s), and to sublicense the foregoing rights on
 ** either these or other terms.
 **
 ** This license is subject to the following condition:
 ** The above copyright notice and either this complete permission notice or at
 ** a minimum a reference to the UPL must be included in all copies or
 ** substantial portions of the Software.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 ** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 ** SOFTWARE.
 */

package oracle.jdbc.provider.util;

import javax.net.ssl.SSLContext;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.KeyStore;
import java.time.OffsetDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoField;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * <p>
 * Represents a wallet zip generated by the ADB service. The contents of the zip
 * archive which are relevant to Oracle JDBC are the tnsnames.ora file, the
 * ojdbc.properties file, and the keystore.jks and truststore.jks files. This
 * exposes the content of these files as higher level abstractions. The
 * connection strings of tnsnames.ora are exposed as {@code String} objects for
 * each consumer group. The JKS keystore and trust store are exposed as an
 * {@link SSLContext} object.
 * </p><p>
 * Along with JKS files, the wallet as a zip also contains SSO and PKCS12 files
 * that contain the same key and trust material. To process these files, Oracle
 * JDBC requires a dependency on the Oracle PKI security provider. The JKS file
 * is chosen over the SSO or PKCS12 files in order to avoid this dependency.
 * </p>
 * <p>
 * It also extracts the expiration date of the wallet's certificates from
 * the {@code README} file included in the wallet zip. The expiration date is
 * used to determine when the wallet should be refreshed.
 * </p>
 */
public final class Wallet {

  /** Name of the tnsnames.ora file in a wallet zip */
  private static final String TNS_NAMES_FILE = "tnsnames.ora";

  /** Name of the keystore file in a wallet zip */
  private static final String KEY_STORE_FILE = "keystore.jks";

  /** Name of the truststore file in a wallet zip */
  private static final String TRUST_STORE_FILE = "truststore.jks";

  /** Type of the keystore file in a wallet zip */
  private static final String KEY_STORE_TYPE = "JKS";

  /** Name of the README file in a wallet zip */
  private static final String README_FILE = "README";

  /** Pattern to match the expiration date line in the README file */
  private static final Pattern EXPIRY_PATTERN = Pattern.compile(
    "The SSL certificates provided in this wallet will expire on ([\\d\\-\\.: ]+ UTC)\\.");

  /** Contents of the tnsnames.ora file */
  private final TNSNames tnsNames;

  /** Expiration date of the wallet's certificates, extracted from the
   * README file */
  private final OffsetDateTime expirationDate;

  /**
   * An {@code SSLContext} initialized with key and trust material of the
   * keystore.jks and truststore.jks files.
   */
  private final SSLContext sslContext;

  /**
   * A static DateTimeFormatter used to parse expiration dates in the README.
   */
  private static final DateTimeFormatter EXPIRATION_DATE_FORMATTER =
    new DateTimeFormatterBuilder()
      .appendPattern("yyyy-MM-dd HH:mm:ss")
      .optionalStart()
      .appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true)
      .optionalEnd()
      .appendPattern("X") // Accept 'Z' as offset
      .toFormatter(Locale.ENGLISH);

  private Wallet(TNSNames tnsNames, SSLContext sslContext, OffsetDateTime expirationDate) {
    this.tnsNames = tnsNames;
    this.sslContext = sslContext;
    this.expirationDate = expirationDate;
  }

  /**
   * @return an {@code SSLContext} initialized with key and trust material from
   * a wallet. Not null.
   */
  public SSLContext getSSLContext() {
    return sslContext;
  }

  /**
   * @return The expiration date of the wallet's certificates, or null if not available.
   */
  public OffsetDateTime getExpirationDate() {
    return expirationDate;
  }

  /**
   * @return The connection string for high consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * high consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getHighConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.HIGH);
  }

  /**
   * @return The connection string for medium consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * medium consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getMediumConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.MEDIUM);
  }

  /**
   * @return The connection string for low consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * low consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getLowConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.LOW);
  }

  /**
   * @return The connection string for transaction processing (tp) consumer
   * group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * transaction processing (tp) consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getTransactionProcessingConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.TRANSACTION_PROCESSING);
  }

  /**
   * @return The connection string for transaction processing urgent (tpurgent)
   * consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * transaction processing urgent (tpurgent) consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getTransactionProcessingUrgentConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.TRANSACTION_PROCESSING_URGENT);
  }

  private String getConnectionString(TNSNames.ConsumerGroup consumerGroup) {
    String connectionString = tnsNames.getConnectionString(consumerGroup);

    if (connectionString == null) {
      throw new IllegalStateException(
        "No connection string available for consumer group: " + consumerGroup);
    }

    return connectionString;
  }

  /**
   * Unzips the stream of a wallet directory, returning a {@code Wallet} that
   * retains the contents of any files relevant to Oracle JDBC.
   * @param zipStream The input stream of the wallet zip file.
   * @param password The password used to decrypt the keystore.
   * @return A new {@code Wallet} instance containing the parsed wallet data.
   * @throws IllegalStateException If the files are not found or can not be
   * decoded.
   */
  public static Wallet unzip(ZipInputStream zipStream, char[] password) {

    TNSNames tnsNames = null;
    KeyStore keyStore = null;
    KeyStore trustStore = null;
    OffsetDateTime expirationDate = null;

    try {
      for (ZipEntry entry = zipStream.getNextEntry(); entry != null; entry = zipStream.getNextEntry()) {
        switch (entry.getName()) {
          case TNS_NAMES_FILE:
            tnsNames = TNSNames.read(zipStream);
            break;
          case KEY_STORE_FILE:
            keyStore =
              TlsUtils.loadKeyStore(zipStream, password, KEY_STORE_TYPE, null);
            break;
          case TRUST_STORE_FILE:
            trustStore =
              TlsUtils.loadKeyStore(zipStream, null, KEY_STORE_TYPE, null);
            break;
          case README_FILE:
            expirationDate = parseExpirationDateFromReadme(zipStream);
            break;
          default:
            // Ignore other files
        }
      }
    }
    catch (IOException ioException) {
      throw new IllegalStateException("Failed to read wallet ZIP", ioException);
    }

    if (tnsNames == null)
      throw missingFile(TNS_NAMES_FILE);

    if (keyStore == null)
      throw missingFile(KEY_STORE_FILE);

    if (trustStore == null)
      throw missingFile(TRUST_STORE_FILE);

    return new Wallet(
      tnsNames,
      TlsUtils.createSSLContext(keyStore, trustStore, password),
      expirationDate);
  }

  /** Returns an exception for a missing file in the wallet ZIP */
  private static IllegalStateException missingFile(String fileName) {
    return new IllegalStateException("Wallet ZIP did not contain: " + fileName);
  }

  /**
   * Reads an {@code InputStream} line by line to find and extract the expiration
   * date of the wallet's certificates using a predefined pattern.
   * Stops reading as soon as the expiration date is found.
   *
   * @param inputStream The input stream to read from. Not null.
   * @return The extracted expiration date string, or {@code null}
   * if no match is found.
   * @throws IOException If an I/O error occurs while reading the stream.
   */
  private static String findExpirationDateInStream(InputStream inputStream)
    throws IOException {
    BufferedReader reader = new BufferedReader(
            new InputStreamReader(inputStream, UTF_8));
    String line;
    while ((line = reader.readLine()) != null) {
      Matcher matcher = EXPIRY_PATTERN.matcher(line);
      if (matcher.find()) {
        return matcher.group(1).trim().replace(" UTC", "Z");
      }
    }
    return null;
  }

  /**
   * Parses the expiration date of the wallet's certificates from the
   * content of a {@code README} file provided as an {@code InputStream}.
   * The method stops reading the stream as soon as the expiration date
   * is found and attempts to parse it into an {@code OffsetDateTime}.
   *
   * @param inputStream The input stream of the {@code README} file.
   * @return The parsed expiration date as an {@code OffsetDateTime},
   * or {@code null} if no expiration date is found or if parsing fails.
   * @throws IOException If an I/O error occurs while reading the stream.
   */
  public static OffsetDateTime parseExpirationDateFromReadme(InputStream inputStream)
          throws IOException {
    if (inputStream == null) {
      return null;
    }
    String expiryDateString = findExpirationDateInStream(inputStream);
    if (expiryDateString == null) {
      return null;
    }
    return parseOffsetDateTime(expiryDateString);
  }

  /**
   * Parses a date-time string into an OffsetDateTime.
   * The method uses the predefined {@code EXPIRATION_DATE_FORMATTER} to parse
   * the given string. If parsing fails due to an invalid format or other reasons,
   * the method returns {@code null}.
   *
   * @param dateTimeString The date-time string to parse.
   * @return The parsed OffsetDateTime, or null if parsing fails.
   */
  private static OffsetDateTime parseOffsetDateTime(String dateTimeString) {
    try {
      return OffsetDateTime.parse(dateTimeString, EXPIRATION_DATE_FORMATTER);
    } catch (DateTimeParseException e) {
      return null;
    }
  }
}
