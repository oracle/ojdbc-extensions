/*
 ** Copyright (c) 2023 Oracle and/or its affiliates.
 **
 ** The Universal Permissive License (UPL), Version 1.0
 **
 ** Subject to the condition set forth below, permission is hereby granted to any
 ** person obtaining a copy of this software, associated documentation and/or data
 ** (collectively the "Software"), free of charge and under any and all copyright
 ** rights in the Software, and any and all patent rights owned or freely
 ** licensable by each licensor hereunder covering either (i) the unmodified
 ** Software as contributed to or provided by such licensor, or (ii) the Larger
 ** Works (as defined below), to deal in both
 **
 ** (a) the Software, and
 ** (b) any piece of software and/or hardware listed in the lrgrwrks.txt file if
 ** one is included with the Software (each a "Larger Work" to which the Software
 ** is contributed by such licensors),
 **
 ** without restriction, including without limitation the rights to copy, create
 ** derivative works of, display, perform, and distribute the Software and make,
 ** use, sell, offer for sale, import, export, have made, and have sold the
 ** Software and the Larger Work(s), and to sublicense the foregoing rights on
 ** either these or other terms.
 **
 ** This license is subject to the following condition:
 ** The above copyright notice and either this complete permission notice or at
 ** a minimum a reference to the UPL must be included in all copies or
 ** substantial portions of the Software.
 **
 ** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 ** IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 ** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 ** AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 ** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 ** OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 ** SOFTWARE.
 */

package oracle.jdbc.provider.util;

import javax.net.ssl.SSLContext;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.KeyStore;
import java.time.OffsetDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;
import java.time.format.DateTimeParseException;
import java.time.temporal.ChronoField;
import java.util.Locale;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import static java.nio.charset.StandardCharsets.UTF_8;

/**
 * <p>
 * Represents a wallet zip generated by the ADB service. The contents of the zip
 * archive which are relevant to Oracle JDBC are the tnsnames.ora file, the
 * ojdbc.properties file, and the keystore.jks and truststore.jks files. This
 * exposes the content of these files as higher level abstractions. The
 * connection strings of tnsnames.ora are exposed as {@code String} objects for
 * each consumer group. The JKS keystore and trust store are exposed as an
 * {@link SSLContext} object.
 * </p><p>
 * Along with JKS files, the wallet as a zip also contains SSO and PKCS12 files
 * that contain the same key and trust material. To process these files, Oracle
 * JDBC requires a dependency on the Oracle PKI security provider. The JKS file
 * is chosen over the SSO or PKCS12 files in order to avoid this dependency.
 * </p>
 * <p>
 * It also extracts the expiration date of the wallet's certificates from
 * the {@code README} file included in the wallet zip. The expiration date is
 * used to determine when the wallet should be refreshed.
 * </p>
 */
public final class Wallet {

  /** Name of the tnsnames.ora file in a wallet zip */
  private static final String TNS_NAMES_FILE = "tnsnames.ora";

  /** Name of the keystore file in a wallet zip */
  private static final String KEY_STORE_FILE = "keystore.jks";

  /** Name of the truststore file in a wallet zip */
  private static final String TRUST_STORE_FILE = "truststore.jks";

  /** Type of the keystore file in a wallet zip */
  private static final String KEY_STORE_TYPE = "JKS";

  /** Name of the README file in a wallet zip */
  private static final String README_FILE = "README";

  /** Pattern to match the expiration date line in the README file */
  private static final Pattern EXPIRY_PATTERN = Pattern.compile(
    "The SSL certificates provided in this wallet will expire on ([\\d\\-\\.: ]+ UTC)\\.",
    Pattern.MULTILINE);

  /** Contents of the tnsnames.ora file */
  private final TNSNames tnsNames;

  /** Expiration date of the wallet's certificates, extracted from the
   * README file */
  private final OffsetDateTime expirationDate;

  /**
   * An {@code SSLContext} initialized with key and trust material of the
   * keystore.jks and truststore.jks files.
   */
  private final SSLContext sslContext;

  private Wallet(TNSNames tnsNames, SSLContext sslContext, OffsetDateTime expirationDate) {
    this.tnsNames = tnsNames;
    this.sslContext = sslContext;
    this.expirationDate = expirationDate;
  }

  /**
   * @return an {@code SSLContext} initialized with key and trust material from
   * a wallet. Not null.
   */
  public SSLContext getSSLContext() {
    return sslContext;
  }

  /**
   * @return The expiration date of the wallet's certificates, or null if not available.
   */
  public OffsetDateTime getExpirationDate() {
    return expirationDate;
  }

  /**
   * @return The connection string for high consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * high consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getHighConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.HIGH);
  }

  /**
   * @return The connection string for medium consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * medium consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getMediumConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.MEDIUM);
  }

  /**
   * @return The connection string for low consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * low consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getLowConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.LOW);
  }

  /**
   * @return The connection string for transaction processing (tp) consumer
   * group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * transaction processing (tp) consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getTransactionProcessingConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.TRANSACTION_PROCESSING);
  }

  /**
   * @return The connection string for transaction processing urgent (tpurgent)
   * consumer group. Not null.
   * @throws IllegalStateException If no connection string is defined for the
   * transaction processing urgent (tpurgent) consumer group.
   * @see <a href="https://docs.oracle.com/en/cloud/paas/autonomous-database/adbsa/connect-predefined-generic.html#GUID-E49773B3-6C07-4F6F-906B-42705D237523">Predefined Consumer Groups</a>
   */
  public String getTransactionProcessingUrgentConnectionString() {
    return getConnectionString(TNSNames.ConsumerGroup.TRANSACTION_PROCESSING_URGENT);
  }

  private String getConnectionString(TNSNames.ConsumerGroup consumerGroup) {
    String connectionString = tnsNames.getConnectionString(consumerGroup);

    if (connectionString == null) {
      throw new IllegalStateException(
        "No connection string available for consumer group: " + consumerGroup);
    }

    return connectionString;
  }

  /**
   * Unzips the stream of a wallet directory, returning a {@code Wallet} that
   * retains the contents of any files relevant to Oracle JDBC.
   * @param zipStream The input stream of the wallet zip file.
   * @param password The password used to decrypt the keystore.
   * @return A new {@code Wallet} instance containing the parsed wallet data.
   * @throws IllegalStateException If the files are not found or can not be
   * decoded.
   */
  public static Wallet unzip(ZipInputStream zipStream, char[] password) {

    TNSNames tnsNames = null;
    KeyStore keyStore = null;
    KeyStore trustStore = null;
    String readmeContent = null;

    try {
      for (ZipEntry entry = zipStream.getNextEntry(); entry != null; entry = zipStream.getNextEntry()) {
        switch (entry.getName()) {
          case TNS_NAMES_FILE:
            tnsNames = TNSNames.read(zipStream);
            break;
          case KEY_STORE_FILE:
            keyStore =
              TlsUtils.loadKeyStore(zipStream, password, KEY_STORE_TYPE, null);
            break;
          case TRUST_STORE_FILE:
            trustStore =
              TlsUtils.loadKeyStore(zipStream, null, KEY_STORE_TYPE, null);
            break;
          case README_FILE:
            readmeContent = readStreamToString(zipStream);
            System.out.println(readmeContent);
            break;
          default:
            // Ignore other files
        }
      }
    }
    catch (IOException ioException) {
      throw new IllegalStateException("Failed to read wallet ZIP", ioException);
    }

    if (tnsNames == null)
      throw missingFile(TNS_NAMES_FILE);

    if (keyStore == null)
      throw missingFile(KEY_STORE_FILE);

    if (trustStore == null)
      throw missingFile(TRUST_STORE_FILE);

    // Parse the expiration date from the README content
    OffsetDateTime expirationDate = null;
    if (readmeContent != null) {
      expirationDate = parseExpirationDateFromReadme(readmeContent);
    }

    return new Wallet(
      tnsNames,
      TlsUtils.createSSLContext(keyStore, trustStore, password),
      expirationDate);
  }

  /** Returns an exception for a missing file in the wallet ZIP */
  private static IllegalStateException missingFile(String fileName) {
    return new IllegalStateException("Wallet ZIP did not contain: " + fileName);
  }

  /**
   * Reads the content of an {@code InputStream} into a {@code String}.
   *
   * @param inputStream The input stream to read from. Not null.
   * @return The content of the input stream as a {@code String}. Not null.
   * @throws IOException If an I/O error occurs while reading the stream.
   */
  private static String readStreamToString(InputStream inputStream)
    throws IOException {
    BufferedReader reader = new BufferedReader(
            new InputStreamReader(inputStream, UTF_8));
    StringBuilder builder = new StringBuilder();
    String line;
    while ((line = reader.readLine()) != null) {
      builder.append(line).append(System.lineSeparator());
    }
    return builder.toString();
  }

  /**
   * Parses the expiration date of the wallet's certificates from the
   * README content.
   *
   * @param readmeContent The content of the README file as a {@code String}.
   * @return The parsed expiration date as an {@code OffsetDateTime}, or null
   * if not found.
   * @throws IllegalStateException If the expiration date cannot be parsed.
   */
  public static OffsetDateTime parseExpirationDateFromReadme(String readmeContent) {
    Matcher matcher = EXPIRY_PATTERN.matcher(readmeContent);
    if (matcher.find()) {
      String expiryDateString = matcher.group(1).trim();
      expiryDateString = expiryDateString.replace(" UTC", "Z");
      System.out.println("expiryDateString: " + expiryDateString);
      DateTimeFormatter formatter = new DateTimeFormatterBuilder()
              .appendPattern("yyyy-MM-dd HH:mm:ss")
              .optionalStart()
              .appendFraction(ChronoField.NANO_OF_SECOND, 0, 9, true)
              .optionalEnd()
              .appendPattern("X") // Accept 'Z' as offset
              .toFormatter(Locale.ENGLISH); // Specify locale explicitly
      System.out.println("formatter: " + formatter);

      try {
        OffsetDateTime expirationDate = OffsetDateTime.parse(expiryDateString, formatter);
        System.out.println("Parsed Expiration Date: " + expirationDate);
        return expirationDate;
      } catch (DateTimeParseException e) {
        throw new IllegalStateException("Failed to parse expiration date from README", e);
      }
    } else {
      return null;
    }
  }

}
